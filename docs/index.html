<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AniManga Ranker</title>
    <!-- Using a specific version of PyScript (2024.9.2) -->
    <link rel="stylesheet" href="https://pyscript.net/snapshots/2024.9.2/core.css" />
    <script type="module" src="https://pyscript.net/snapshots/2024.9.2/core.js"></script>
    <style>
      /* Ensure the HTML and body fill the viewport */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Container uses a flex column layout to allow bottom elements to grow */
      .container {
        display: flex;
        flex-direction: column;
        height: 100vh; /* full viewport height */
        width: 90%;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
      }
      /* Updated heading styling: less vertical space */
      header {
        flex: 0 0 auto;
        text-align: center;
        padding: 10px 20px;
        background-color: #f0f0f0;
        margin-bottom: 10px;
      }
      header h1 {
        margin: 0;
        font-size: 1.8em;
      }
      /* Control panel remains at the top with auto height */
      .control-panel {
        flex: 0 0 auto;
        margin-bottom: 10px;
      }
      .username-status {
        text-align: center;
        margin-bottom: 10px;
      }
      /* Row for main buttons and dropdowns. */
      .controls-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        justify-content: center;
        margin-bottom: 10px;
      }
      .btn-group {
        display: flex;
        gap: 10px;
      }
      .btn-group button {
        padding: 8px 12px;
        font-size: 1em;
        cursor: pointer;
      }
      .dropdown-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .dropdown-group label,
      .dropdown-group select {
        font-size: 16px;
      }
      /* Progress info arranged side by side */
      .progress-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 10px;
      }
      #progressLabel,
      #unsortedComparisonsLabel {
        font-size: 16px;
      }
      /* The comparison panel fills the remaining vertical space */
      .comparison-panel {
        flex: 1; /* expand to fill leftover vertical space */
        display: flex;
        gap: 10px;
        margin-top: 20px;
        align-items: stretch; /* ensure children stretch vertically */
      }
      /* Comparison buttons: fill available space and center content */
      .comparison-button {
        flex: 1;
        padding: 20px;
        font-size: 18px;
        cursor: pointer;
        background-color: #555;
        color: white;
        border: none;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .comparison-button:hover {
        background-color: #666;
      }
      /* Button styling for all generic buttons */
      button {
        background-color: #555;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        cursor: pointer;
      }
      button:hover {
        background-color: #666;
      }
      /* Modal styling */
      .modal {
        display: none;
        position: fixed;
        z-index: 10;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      }
      .modal-content {
        background-color: #333;
        margin: 10% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        color: #f8f8f2;
      }
      .modal-content button {
        margin: 5px;
        font-size: 16px;
      }
      /* Debug info panel and toggle button */
      #debugInfo {
        display: none;
        position: fixed;
        top: 40px;
        right: 5px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 5px;
        font-size: 12px;
        z-index: 9999;
        white-space: pre-line;
      }
      #debugToggle {
        position: fixed;
        top: 5px;
        right: 5px;
        background: #555;
        color: white;
        padding: 5px;
        z-index: 10000;
        cursor: pointer;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <!-- Debug toggle button -->
    <div id="debugToggle">DEBUG</div>
    <!-- Debug info panel -->
    <div id="debugInfo"></div>
    
    <div class="container">
      <!-- Compact Heading -->
      <header>
        <h1>AniManga Ranker</h1>
      </header>
      
      <div class="control-panel">
        <!-- Username and checkboxes -->
        <div class="username-status">
          <div>
            <label for="usernameInput">Enter AniList Username:</label>
            <input type="text" id="usernameInput" placeholder="Username" title="Enter your AniList username" />
          </div>
          <div>
            <label>
              <input type="checkbox" id="completedCheckbox" checked> Completed
            </label>
            <label>
              <input type="checkbox" id="watchingCheckbox"> Watching/Reading
            </label>
            <label>
              <input type="checkbox" id="pausedCheckbox"> Paused
            </label>
            <label>
              <input type="checkbox" id="droppedCheckbox"> Dropped
            </label>
            <label>
              <input type="checkbox" id="includeImagesCheckbox"> Include Images
            </label>
          </div>
        </div>
        
        <!-- Row containing the four main buttons and dropdowns -->
        <div class="controls-row">
          <div class="btn-group">
            <button id="fetchAnimeButton">Fetch Anime List</button>
            <button id="fetchMangaButton">Fetch Manga List</button>
            <button id="editSortedButton">Edit Sorted List</button>
            <button id="finishEarlyButton">Finish List Early</button>
          </div>
          <div class="dropdown-group">
            <label for="seasonDropdown">Season:</label>
            <select id="seasonDropdown"></select>
            <label for="yearDropdown">Year:</label>
            <select id="yearDropdown"></select>
          </div>
        </div>
        
        <!-- Progress and status -->
        <div class="progress-row">
          <div id="progressLabel">Inserted 0 of 0. Remaining: 0 items (0% complete).</div>
          <div id="unsortedComparisonsLabel">Estimated Total Comparisons Left: 0</div>
        </div>
        
        <!-- Instruction text -->
        <div id="instructionLabel">Comparison instructions will appear here</div>
      </div>
      
      <!-- Comparison buttons panel filling remaining vertical space -->
      <div class="comparison-panel">
        <button class="comparison-button" id="compButton1">NEW wins</button>
        <button class="comparison-button" id="compButton2">Candidate wins</button>
      </div>
    </div>
    
    <!-- Edit Sorted List Modal (drag-and-drop enabled) -->
    <div id="editModal" class="modal">
      <div class="modal-content">
        <h2>Edit Sorted List</h2>
        <div id="editModalContent"></div>
        <div style="text-align: center;">
          <button id="saveEditButton">Save</button>
          <button id="closeEditButton">Close</button>
        </div>
      </div>
    </div>
    
    <!-- Final Ranking Modal -->
    <div id="finalModal" class="modal">
      <div class="modal-content">
        <h2>Final Ranking</h2>
        <div id="finalModalContent"></div>
        <div style="text-align: center;">
          <button id="closeFinalButton">Close</button>
        </div>
      </div>
    </div>
    
    <!-- Python code (PyScript) -->
    <script type="py">
import math, random, json
from js import document, console
from pyodide.http import pyfetch
from pyodide.ffi import create_proxy

ANILIST_API_URL = "https://graphql.anilist.co"

class AniMangaRanker:
    def __init__(self):
        # Tournament state variables
        self.all_items = []  # All fetched items
        self.unsorted_list = []  # Items to be inserted in ranking
        self.sorted_list = []  # Ranked items
        self.current_index = 0
        self.low_index = 0
        self.high_index = 0
        self.offset = 15
        self.initial_estimated_midpoint = None
        self.initial_low_bound = None
        self.comparisons_remaining = 0
        self.unsorted_comparisons_remaining = 0

    # ---------- DOM Utility Methods ----------
    def set_text(self, element_id, text):
        document.getElementById(element_id).innerText = text

    def get_value(self, element_id):
        return document.getElementById(element_id).value

    def is_checked(self, element_id):
        return document.getElementById(element_id).checked

    # ---------- AniList API Functions ----------
    def build_query(self, media_type, status):
        return (
            "query ($name: String) { "
            "MediaListCollection(userName: $name, type: " + media_type + ", status: " + status + ") { "
            "lists { entries { score media { id title { english romaji } coverImage { large } season seasonYear } } } } }"
        )

    def get_selected_statuses(self, media_type):
        statuses = []
        if self.is_checked("completedCheckbox"):
            statuses.append("COMPLETED")
        if self.is_checked("watchingCheckbox"):
            statuses.append("CURRENT" if media_type == "ANIME" else "READING")
        if self.is_checked("pausedCheckbox"):
            statuses.append("PAUSED")
        if self.is_checked("droppedCheckbox"):
            statuses.append("DROPPED")
        return statuses

    async def fetch_user_list(self, username, media_type):
        statuses = self.get_selected_statuses(media_type)
        if not statuses:
            self.set_text("progressLabel", "No list statuses selected!")
            return []
        results = []
        seen = set()
        for status in statuses:
            query = self.build_query(media_type, status)
            variables = {"name": username}
            payload = {"query": query, "variables": variables}
            try:
                response = await pyfetch(
                    url=ANILIST_API_URL,
                    method="POST",
                    headers={"Content-Type": "application/json"},
                    body=json.dumps(payload)
                )
                if not response.ok:
                    console.log("Error fetching data: " + str(response.status))
                    continue
                data = await response.json()
            except Exception as e:
                console.log("Error fetching " + media_type + " list for " + username + ": " + str(e))
                continue
            raw_lists = data.get("data", {}).get("MediaListCollection", {}).get("lists", [])
            for lst in raw_lists:
                for entry in lst.get("entries", []):
                    media = entry.get("media")
                    if media:
                        mid = media.get("id")
                        if mid in seen:
                            continue
                        seen.add(mid)
                        title = (media.get("title", {}).get("english") or media.get("title", {}).get("romaji") or "Unknown")
                        cover = media.get("coverImage", {}).get("large", "")
                        season = media.get("season")
                        seasonYear = media.get("seasonYear")
                        score = entry.get("score", 0)
                        results.append((mid, title, cover, score, season, seasonYear))
            results.sort(key=lambda x: x[3], reverse=True)
            new_results = []
            current_score = None
            group = []
            for item in results:
                score = item[3]
                if current_score is None or score == current_score:
                    group.append(item)
                    current_score = score
                else:
                    random.shuffle(group)
                    new_results.extend(group)
                    group = [item]
                    current_score = score
            if group:
                random.shuffle(group)
                new_results.extend(group)
        return new_results

    # ---------- Tournament and Comparison Functions ----------
    def estimated_unsorted_comparisons_remaining(self):
        sorted_count = len(self.sorted_list)
        remaining_count = len(self.unsorted_list) - self.current_index
        total = 0
        for k in range(remaining_count):
            total += math.ceil(math.log2(sorted_count + k + 1))
        return total

    def reset_binary_range(self):
        self.high_index = len(self.sorted_list) - 1
        if self.high_index >= 2 * self.offset:
            self.low_index = self.high_index - 2 * self.offset
        else:
            self.low_index = 0
        self.initial_low_bound = self.low_index
        candidate = self.low_index + self.offset
        if candidate <= self.high_index:
            self.initial_estimated_midpoint = candidate
        else:
            self.initial_estimated_midpoint = (self.low_index + self.high_index) // 2
        self.comparisons_remaining = ( math.ceil(math.log2(self.high_index - self.low_index + 1)) if (self.high_index - self.low_index + 1) > 0 else 0 )
        self.unsorted_comparisons_remaining = self.estimated_unsorted_comparisons_remaining()
        self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))

    def calculate_mid(self):
        if self.initial_low_bound is not None and self.initial_low_bound >= 0 and self.low_index == 0:
            return (self.low_index + self.high_index) // 2
        else:
            candidate = self.low_index + self.offset
            return candidate if candidate <= self.high_index else (self.low_index + self.high_index) // 2

    def update_progress(self):
        total = len(self.unsorted_list)
        inserted = len(self.sorted_list)
        remaining_items = total - inserted
        progress_percentage = (inserted / total * 100) if total > 0 else 0
        self.set_text("progressLabel", "Inserted " + str(inserted) + " of " + str(total) + ". Remaining: " + str(remaining_items) + " items ({:.1f}% complete).".format(progress_percentage))

    def update_comparison_gui(self):
        try:
            if self.current_index >= len(self.unsorted_list):
                return
            new_item = self.unsorted_list[self.current_index]
            if not self.sorted_list:
                self.sorted_list.append(new_item)
                self.current_index += 1
                self.reset_binary_range()
                if self.current_index < len(self.unsorted_list):
                    self.update_comparison_gui()
                else:
                    self.show_final_results()
                return
            mid = self.calculate_mid()
            if mid < 0 or mid >= len(self.sorted_list):
                mid = 0
            candidate = self.sorted_list[mid]
            self.set_text("instructionLabel", "Compare:\n\n" + new_item[1] + "\nvs.\n" + candidate[1])
            btn1 = document.getElementById("compButton1")
            btn2 = document.getElementById("compButton2")
            include_images = self.is_checked("includeImagesCheckbox")
            if include_images and new_item[2] and candidate[2]:
                btn1.innerHTML = f'<img src="{new_item[2]}" alt="Cover for {new_item[1]}" style="max-width:200px;height:auto;"><br>{new_item[1]}'
                btn2.innerHTML = f'<img src="{candidate[2]}" alt="Cover for {candidate[1]}" style="max-width:200px;height:auto;"><br>{candidate[1]}'
            else:
                btn1.innerText = new_item[1]
                btn2.innerText = candidate[1]
            self.update_progress()
            self.update_debug_info()
        except Exception as e:
            console.log("Error in update_comparison_gui: " + str(e))

    def handle_comparison(self, new_item_wins):
        try:
            if self.unsorted_comparisons_remaining > 0:
                self.unsorted_comparisons_remaining -= 1
                self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))
            mid = self.calculate_mid()
            if self.low_index >= self.high_index:
                if new_item_wins and self.initial_low_bound is not None and self.initial_low_bound != 0 and self.low_index == self.initial_low_bound:
                    self.high_index = self.initial_low_bound
                    self.low_index = 0
                    self.update_comparison_gui()
                    return
                else:
                    insertion_index = self.low_index if new_item_wins else self.low_index + 1
                    self.sorted_list.insert(insertion_index, self.unsorted_list[self.current_index])
                    self.current_index += 1
                    self.reset_binary_range()
                    if self.current_index < len(self.unsorted_list):
                        self.update_comparison_gui()
                    else:
                        self.show_final_results()
                    return
            if new_item_wins:
                self.high_index = mid - 1
            else:
                self.low_index = mid + 1
            if self.low_index >= self.high_index:
                insertion_index = self.low_index if new_item_wins else self.low_index + 1
                self.sorted_list.insert(insertion_index, self.unsorted_list[self.current_index])
                self.current_index += 1
                self.reset_binary_range()
                if self.current_index < len(self.unsorted_list):
                    self.update_comparison_gui()
                else:
                    self.show_final_results()
            else:
                self.update_comparison_gui()
        except Exception as e:
            console.log("Error in handle_comparison: " + str(e))

    def handle_new_win(self, e):
        self.handle_comparison(True)

    def handle_candidate_win(self, e):
        self.handle_comparison(False)

    def show_final_results(self):
        try:
            final_text = "Final Ranking (Best to Worst):\n\n"
            for i, comp in enumerate(self.sorted_list):
                final_text += str(i+1) + ". " + comp[1] + "\n"
            finalModal = document.getElementById("finalModal")
            document.getElementById("finalModalContent").innerText = final_text
            finalModal.style.display = "block"
            self.set_text("progressLabel", "Ranking complete!")
        except Exception as e:
            console.log("Error in show_final_results: " + str(e))

    async def start_fetch(self, media_type):
        try:
            username = self.get_value("usernameInput").strip()
            if not username:
                self.set_text("progressLabel", "Please enter a username!")
                return
            self.set_text("progressLabel", "Fetching data, please wait...")
            items = await self.fetch_user_list(username, media_type)
            if not items:
                self.set_text("progressLabel", "No completed " + media_type.lower() + " found for " + username)
                return
            self.all_items = items
            self.update_dropdowns()  # Update dropdowns based on fetched data
            self.unsorted_list = items
            self.sorted_list = [items[0]]
            self.current_index = 1
            self.reset_binary_range()
            self.update_progress()
            self.update_comparison_gui()
        except Exception as e:
            console.log("Error in start_fetch: " + str(e))

    def update_dropdowns(self):
        try:
            # Preserve current selection (default to "All")
            current_year = document.getElementById("yearDropdown").value or "All"
            current_season = document.getElementById("seasonDropdown").value or "All"
            # Update Season dropdown counts based on current year filter
            seasons = {"Winter": 0, "Spring": 0, "Summer": 0, "Fall": 0}
            for item in self.all_items:
                if current_year != "All":
                    if not item[5] or str(item[5]) != current_year:
                        continue
                if item[4]:
                    s = item[4].capitalize()
                    if s in seasons:
                        seasons[s] += 1
            total_seasons = sum(seasons.values())
            season_dropdown = document.getElementById("seasonDropdown")
            season_dropdown.innerHTML = ""
            opt = document.createElement("option")
            opt.value = "All"
            opt.text = "All (" + str(total_seasons) + ")"
            season_dropdown.appendChild(opt)
            for s, count in seasons.items():
                if count > 0:
                    opt = document.createElement("option")
                    opt.value = s
                    opt.text = f"{s} ({count})"
                    season_dropdown.appendChild(opt)
            season_dropdown.value = current_season;
            
            # Update Year dropdown counts based on current season filter
            year_counts = {}
            for item in self.all_items:
                if current_season != "All":
                    if not item[4] or item[4].capitalize() != current_season:
                        continue
                if item[5]:
                    yr = str(item[5])
                    year_counts[yr] = year_counts.get(yr, 0) + 1
            total_years = sum(year_counts.values())
            year_dropdown = document.getElementById("yearDropdown")
            year_dropdown.innerHTML = ""
            opt = document.createElement("option")
            opt.value = "All"
            opt.text = "All (" + str(total_years) + ")"
            year_dropdown.appendChild(opt)
            for year in sorted(year_counts.keys()):
                opt = document.createElement("option")
                opt.value = year
                opt.text = f"{year} ({year_counts[year]})"
                year_dropdown.appendChild(opt)
            year_dropdown.value = current_year;
        except Exception as e:
            console.log("Error in update_dropdowns: " + str(e))

    def filter_changed(self, e=None):
        try:
            self.update_dropdowns()
            season = document.getElementById("seasonDropdown").value
            year = document.getElementById("yearDropdown").value
            filtered = []
            for item in self.all_items:
                if season != "All" and (not item[4] or item[4].lower() != season.lower()):
                    continue
                if year != "All" and (not item[5] or str(item[5]) != year):
                    continue
                filtered.append(item)
            if not filtered:
                self.set_text("progressLabel", "No entries match the selected filters!")
                return
            self.unsorted_list = filtered
            self.sorted_list = [filtered[0]]
            self.current_index = 1
            self.reset_binary_range()
            self.update_progress()
            self.update_comparison_gui()
        except Exception as e:
            console.log("Error in filter_changed: " + str(e))

    def edit_sorted_list(self):
        try:
            modal = document.getElementById("editModal")
            modal.style.display = "block"
            self.refresh_edit_modal()
        except Exception as e:
            console.log("Error in edit_sorted_list: " + str(e))

    def on_drag_start(self, e, index):
        e.dataTransfer.setData("text/plain", str(index))

    def on_drag_over(self, e):
        e.preventDefault()

    def on_drop(self, e, index):
        e.preventDefault()
        src_index = int(e.dataTransfer.getData("text/plain"))
        if src_index != index:
            item = self.sorted_list.pop(src_index)
            self.sorted_list.insert(index, item)
            self.refresh_edit_modal()

    def refresh_edit_modal(self):
        try:
            content = document.getElementById("editModalContent")
            content.innerHTML = ""
            ol = document.createElement("ol")
            for idx, item in enumerate(self.sorted_list):
                li = document.createElement("li")
                li.innerText = item[1]
                li.setAttribute("draggable", "true")
                li.style.cursor = "move"
                li.addEventListener("dragstart", create_proxy(lambda e, i=idx: self.on_drag_start(e, i)))
                li.addEventListener("dragover", create_proxy(self.on_drag_over))
                li.addEventListener("drop", create_proxy(lambda e, i=idx: self.on_drop(e, i)))
                ol.appendChild(li)
            content.appendChild(ol)
        except Exception as e:
            console.log("Error in refresh_edit_modal: " + str(e))

    def save_edited_list(self):
        try:
            modal = document.getElementById("editModal")
            modal.style.display = "none"
            self.set_text("progressLabel", "Edited sorted list saved.")
        except Exception as e:
            console.log("Error in save_edited_list: " + str(e))

    def close_edit_modal(self):
        try:
            modal = document.getElementById("editModal")
            modal.style.display = "none"
        except Exception as e:
            console.log("Error in close_edit_modal: " + str(e))

    def finish_early(self):
        try:
            self.show_final_results()
        except Exception as e:
            console.log("Error in finish_early: " + str(e))

    def show_final_results(self):
        try:
            final_text = "Final Ranking (Best to Worst):\n\n"
            for i, comp in enumerate(self.sorted_list):
                final_text += str(i+1) + ". " + comp[1] + "\n"
            finalModal = document.getElementById("finalModal")
            document.getElementById("finalModalContent").innerText = final_text
            finalModal.style.display = "block"
            self.set_text("progressLabel", "Ranking complete!")
        except Exception as e:
            console.log("Error in show_final_results: " + str(e))

    def update_debug_info(self):
        try:
            debugInfo = document.getElementById("debugInfo")
            low_item = self.sorted_list[self.low_index][1] if self.sorted_list and self.low_index < len(self.sorted_list) else "N/A"
            high_item = self.sorted_list[self.high_index][1] if self.sorted_list and self.high_index < len(self.sorted_list) else "N/A"
            initial_item = self.sorted_list[self.initial_estimated_midpoint][1] if self.initial_estimated_midpoint is not None and self.sorted_list and self.initial_estimated_midpoint < len(self.sorted_list) else "N/A"
            current_mid = self.calculate_mid()
            current_item = self.sorted_list[current_mid][1] if self.sorted_list and current_mid < len(self.sorted_list) else "N/A"
            info = (f"Low bound: {low_item} (index {self.low_index})\n"
                    f"High bound: {high_item} (index {self.high_index})\n"
                    f"Initial midpoint: {initial_item} (index {self.initial_estimated_midpoint})\n"
                    f"Current midpoint: {current_item} (index {current_mid})")
            debugInfo.innerText = info
        except Exception as e:
            console.log("Error updating debug info: " + str(e))

# Create the global instance of ranker
ranker = AniMangaRanker()

# ---------- Bind Event Listeners using create_proxy ----------
fetchAnimeProxy = create_proxy(lambda e: __import__('asyncio').create_task(ranker.start_fetch("ANIME")))
fetchMangaProxy = create_proxy(lambda e: __import__('asyncio').create_task(ranker.start_fetch("MANGA")))
compButton1Proxy = create_proxy(ranker.handle_new_win)
compButton2Proxy = create_proxy(ranker.handle_candidate_win)
editSortedProxy = create_proxy(lambda e: ranker.edit_sorted_list())
finishEarlyProxy = create_proxy(lambda e: ranker.finish_early())
saveEditProxy = create_proxy(lambda e: ranker.save_edited_list())
closeEditProxy = create_proxy(lambda e: ranker.close_edit_modal())
seasonChangeProxy = create_proxy(lambda e: ranker.filter_changed())
yearChangeProxy = create_proxy(lambda e: ranker.filter_changed())
closeFinalProxy = create_proxy(lambda e: setattr(document.getElementById("finalModal").style, "display", "none"))

document.getElementById("fetchAnimeButton").addEventListener("click", fetchAnimeProxy)
document.getElementById("fetchMangaButton").addEventListener("click", fetchMangaProxy)
document.getElementById("compButton1").addEventListener("click", compButton1Proxy)
document.getElementById("compButton2").addEventListener("click", compButton2Proxy)
document.getElementById("editSortedButton").addEventListener("click", editSortedProxy)
document.getElementById("finishEarlyButton").addEventListener("click", finishEarlyProxy)
document.getElementById("saveEditButton").addEventListener("click", saveEditProxy)
document.getElementById("closeEditButton").addEventListener("click", closeEditProxy)
document.getElementById("seasonDropdown").addEventListener("change", seasonChangeProxy)
document.getElementById("yearDropdown").addEventListener("change", yearChangeProxy)
document.getElementById("closeFinalButton").addEventListener("click", closeFinalProxy)
    </script>
    
    <!-- Toggle debug info visibility -->
    <script>
      document.getElementById("debugToggle").addEventListener("click", function(){
        var dbg = document.getElementById("debugInfo");
        if (dbg.style.display === "none" || dbg.style.display === "") {
          dbg.style.display = "block";
        } else {
          dbg.style.display = "none";
        }
      });
    </script>
  </body>
</html>
