<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AniManga Ranker – PyScript Edition</title>
    <!-- Using a specific version is recommended; here we use the latest core files -->
    <link rel="stylesheet" href="https://pyscript.net/latest/core.css" />
    <script defer type="module" src="https://pyscript.net/latest/core.js"></script>
    <style>
      /* General layout styling */
      body {
        background-color: #2e2e2e;
        color: #f8f8f2;
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
      }
      .container {
        width: 90%;
        margin: auto;
        padding: 20px;
      }
      h1 {
        text-align: center;
        margin-bottom: 20px;
      }
      .control-panel {
        text-align: center;
        margin-bottom: 20px;
      }
      .control-panel div {
        margin: 10px 0;
      }
      .comparison-panel {
        display: flex;
        justify-content: space-around;
        margin-top: 20px;
      }
      .comparison-button {
        width: 45%;
        padding: 15px;
        font-size: 18px;
        cursor: pointer;
      }
      /* Filter dropdowns and extra buttons */
      #filter-panel label,
      #filter-panel select {
        font-size: 16px;
        margin-right: 10px;
      }
      #editFinishPanel button, #extraButtons button {
        font-size: 16px;
        margin: 5px;
        padding: 5px 10px;
      }
      /* Modal styling for editing sorted list and debugging */
      .modal {
        display: none;
        position: fixed;
        z-index: 10;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      }
      .modal-content {
        background-color: #333;
        margin: 10% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        color: #f8f8f2;
      }
      .modal-content button {
        margin: 5px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AniManga Ranker – PyScript Edition</h1>
      <div class="control-panel">
        <!-- Username and status checkboxes -->
        <div>
          <label for="usernameInput">Enter AniList Username:</label>
          <input type="text" id="usernameInput" placeholder="Username" />
        </div>
        <div>
          <label><input type="checkbox" id="completedCheckbox" checked> Completed</label>
          <label><input type="checkbox" id="watchingCheckbox"> Watching/Reading</label>
          <label><input type="checkbox" id="pausedCheckbox"> Paused</label>
          <label><input type="checkbox" id="droppedCheckbox"> Dropped</label>
          <label><input type="checkbox" id="includeImagesCheckbox"> Include Images</label>
        </div>
        <!-- Fetch buttons -->
        <div>
          <button id="fetchAnimeButton">Fetch Anime List</button>
          <button id="fetchMangaButton">Fetch Manga List</button>
        </div>
        <!-- Filter dropdowns -->
        <div id="filter-panel">
          <label for="seasonDropdown">Season:</label>
          <!-- When a filter changes, we call the Python function -->
          <select id="seasonDropdown" onchange="pyodide.runPython('ranker.filter_changed()');"></select>
          <label for="yearDropdown">Year:</label>
          <select id="yearDropdown" onchange="pyodide.runPython('ranker.filter_changed()');"></select>
        </div>
        <!-- Edit, Finish, Reset, and Debug buttons -->
        <div id="editFinishPanel">
          <button id="editSortedButton">Edit Sorted List</button>
          <button id="finishEarlyButton">Finish List Early</button>
        </div>
        <div id="extraButtons" style="text-align: center;">
          <button id="resetButton">Reset Tournament</button>
          <button id="debugButton">Show Debug Info</button>
        </div>
        <!-- Progress and Instructions -->
        <div id="progressLabel"></div>
        <div id="instructionLabel">Comparison instructions will appear here</div>
        <div id="unsortedComparisonsLabel">Estimated Total Comparisons Left: 0</div>
      </div>
      <!-- Comparison buttons -->
      <div class="comparison-panel">
        <button class="comparison-button" id="compButton1">NEW wins</button>
        <button class="comparison-button" id="compButton2">Candidate wins</button>
      </div>
    </div>

    <!-- Edit Sorted List Modal -->
    <div id="editModal" class="modal">
      <div class="modal-content">
        <h2>Edit Sorted List</h2>
        <div id="editModalContent"></div>
        <div style="text-align: center;">
          <button id="saveEditButton">Save</button>
          <button id="closeEditButton">Close</button>
        </div>
      </div>
    </div>

    <!-- Debug Modal -->
    <div id="debugModal" class="modal">
      <div class="modal-content">
        <h2>Debug Info</h2>
        <div id="debugModalContent"></div>
        <div style="text-align: center;">
          <button id="closeDebugButton">Close</button>
        </div>
      </div>
    </div>

    <py-script>
import math, random, json
from js import document, console, fetch

ANILIST_API_URL = "https://graphql.anilist.co"

class AniMangaRanker:
    def __init__(self):
        # Tournament state
        self.all_items = []       # All fetched items
        self.unsorted_list = []   # Items to be inserted in ranking
        self.sorted_list = []     # Ranked items
        self.current_index = 0
        self.low_index = 0
        self.high_index = 0
        self.offset = 15
        self.initial_estimated_midpoint = None
        self.initial_low_bound = None
        self.comparisons_remaining = 0
        self.unsorted_comparisons_remaining = 0

    # ---------- DOM Utility Methods ----------
    def set_text(self, element_id, text):
        document.getElementById(element_id).innerText = text

    def get_value(self, element_id):
        return document.getElementById(element_id).value

    def is_checked(self, element_id):
        return document.getElementById(element_id).checked

    # ---------- AniList API Functions ----------
    def build_query(self, media_type, status):
        # Build query by concatenating strings (to avoid f-string issues in PyScript)
        query = (
            "query ($name: String) { "
            "MediaListCollection(userName: $name, type: " + media_type + ", status: " + status + ") { "
            "lists { entries { score media { id title { english romaji } coverImage { large } season seasonYear } } } } }"
        )
        return query

    def get_selected_statuses(self, media_type):
        statuses = []
        if self.is_checked("completedCheckbox"):
            statuses.append("COMPLETED")
        if self.is_checked("watchingCheckbox"):
            statuses.append("CURRENT" if media_type == "ANIME" else "READING")
        if self.is_checked("pausedCheckbox"):
            statuses.append("PAUSED")
        if self.is_checked("droppedCheckbox"):
            statuses.append("DROPPED")
        return statuses

    async def fetch_user_list(self, username, media_type):
        statuses = self.get_selected_statuses(media_type)
        if not statuses:
            self.set_text("progressLabel", "No list statuses selected!")
            return []
        results = []
        seen = set()
        for status in statuses:
            query = self.build_query(media_type, status)
            variables = {"name": username}
            payload = {"query": query, "variables": variables}
            init = {
                "method": "POST",
                "headers": {"Content-Type": "application/json"},
                "body": json.dumps(payload)
            }
            try:
                response = await fetch(ANILIST_API_URL, init)
                if not response.ok:
                    console.log("Error fetching data: " + response.statusText)
                    continue
                data = await response.json()
            except Exception as e:
                console.log("Error fetching " + media_type + " list for " + username + ": " + str(e))
                continue
            raw_lists = data.get("data", {}).get("MediaListCollection", {}).get("lists", [])
            for lst in raw_lists:
                for entry in lst.get("entries", []):
                    media = entry.get("media")
                    if media:
                        mid = media.get("id")
                        if mid in seen:
                            continue
                        seen.add(mid)
                        title = (media.get("title", {}).get("english") or 
                                 media.get("title", {}).get("romaji") or "Unknown")
                        cover = media.get("coverImage", {}).get("large") or ""
                        season = media.get("season")
                        seasonYear = media.get("seasonYear")
                        score = entry.get("score", 0)
                        results.append((mid, title, cover, score, season, seasonYear))
        results.sort(key=lambda x: x[3], reverse=True)
        new_results = []
        current_score = None
        group = []
        for item in results:
            score = item[3]
            if current_score is None or score == current_score:
                group.append(item)
                current_score = score
            else:
                random.shuffle(group)
                new_results.extend(group)
                group = [item]
                current_score = score
        if group:
            random.shuffle(group)
            new_results.extend(group)
        return new_results

    # ---------- Tournament and Comparison Functions ----------
    def estimated_unsorted_comparisons_remaining(self):
        sorted_count = len(self.sorted_list)
        remaining_count = len(self.unsorted_list) - self.current_index
        total = 0
        for k in range(remaining_count):
            total += math.ceil(math.log2(sorted_count + k + 1))
        return total

    def reset_binary_range(self):
        self.high_index = len(self.sorted_list) - 1
        if self.high_index >= 2 * self.offset:
            self.low_index = self.high_index - 2 * self.offset
        else:
            self.low_index = 0
        self.initial_low_bound = self.low_index
        candidate = self.low_index + self.offset
        if candidate <= self.high_index:
            self.initial_estimated_midpoint = candidate
        else:
            self.initial_estimated_midpoint = (self.low_index + self.high_index) // 2
        self.comparisons_remaining = (math.ceil(math.log2(self.high_index - self.low_index + 1))
                                      if (self.high_index - self.low_index + 1) > 0 else 0)
        self.unsorted_comparisons_remaining = self.estimated_unsorted_comparisons_remaining()
        self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))

    def calculate_mid(self):
        if self.initial_low_bound is not None and self.initial_low_bound > 0 and self.low_index == 0:
            return (self.low_index + self.high_index) // 2
        else:
            candidate = self.low_index + self.offset
            return candidate if candidate <= self.high_index else (self.low_index + self.high_index) // 2

    def update_progress(self):
        total = len(self.unsorted_list)
        inserted = len(self.sorted_list)
        remaining_items = total - inserted
        progress_percentage = (inserted / total * 100) if total > 0 else 0
        self.set_text("progressLabel", "Inserted " + str(inserted) + " of " + str(total) +
                     ". Remaining: " + str(remaining_items) + " items (" + "{:.1f}".format(progress_percentage) + "% complete).")

    def update_comparison_gui(self):
        if self.current_index >= len(self.unsorted_list):
            return
        new_item = self.unsorted_list[self.current_index]
        mid = self.calculate_mid()
        if mid < 0 or mid >= len(self.sorted_list):
            return
        candidate = self.sorted_list[mid]
        self.set_text("instructionLabel", "Compare:\n\n" + new_item[1] + "\nvs.\n" + candidate[1])
        btn1 = document.getElementById("compButton1")
        btn2 = document.getElementById("compButton2")
        include_images = self.is_checked("includeImagesCheckbox")
        if include_images:
            btn1.innerHTML = '<img src="' + new_item[2] + '" style="max-width:200px;height:auto;"><br>' + new_item[1]
            btn2.innerHTML = '<img src="' + candidate[2] + '" style="max-width:200px;height:auto;"><br>' + candidate[1]
        else:
            btn1.innerText = new_item[1]
            btn2.innerText = candidate[1]
        self.update_progress()

    def handle_comparison(self, new_item_wins):
        if self.unsorted_comparisons_remaining > 0:
            self.unsorted_comparisons_remaining -= 1
            self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))
        mid = self.calculate_mid()
        if self.low_index >= self.high_index:
            if new_item_wins and self.initial_low_bound is not None and self.initial_low_bound != 0 and self.low_index == self.initial_low_bound:
                self.high_index = self.initial_low_bound
                self.low_index = 0
                self.update_comparison_gui()
                return
            else:
                insertion_index = self.low_index if new_item_wins else self.low_index + 1
                self.sorted_list.insert(insertion_index, self.unsorted_list[self.current_index])
                self.current_index += 1
                self.reset_binary_range()
                if self.current_index < len(self.unsorted_list):
                    self.update_comparison_gui()
                else:
                    self.show_final_results()
                return
        if new_item_wins:
            self.high_index = mid - 1
        else:
            self.low_index = mid + 1
        if self.low_index > self.high_index:
            insertion_index = self.low_index if new_item_wins else self.low_index + 1
            self.sorted_list.insert(insertion_index, self.unsorted_list[self.current_index])
            self.current_index += 1
            self.reset_binary_range()
            if self.current_index < len(self.unsorted_list):
                self.update_comparison_gui()
            else:
                self.show_final_results()
        else:
            self.update_comparison_gui()

    def handle_new_win(self, e):
        self.handle_comparison(True)

    def handle_candidate_win(self, e):
        self.handle_comparison(False)

    def show_final_results(self):
        final_text = "Final Ranking (Best to Worst):\n\n"
        for i, comp in enumerate(self.sorted_list):
            final_text += str(i+1) + ". " + comp[1] + "\n"
        self.set_text("instructionLabel", final_text)
        self.set_text("progressLabel", "Ranking complete!")

    async def start_fetch(self, media_type):
        username = self.get_value("usernameInput").strip()
        if not username:
            self.set_text("progressLabel", "Please enter a username!")
            return
        self.set_text("progressLabel", "Fetching data, please wait...")
        items = await self.fetch_user_list(username, media_type)
        if not items:
            self.set_text("progressLabel", "No completed " + media_type.lower() + " found for " + username)
            return
        self.all_items = items
        self.update_dropdowns()
        self.unsorted_list = items
        self.sorted_list = [items[0]]
        self.current_index = 1
        self.reset_binary_range()
        self.update_progress()
        self.update_comparison_gui()

    # ---------- Filtering Functions ----------
    def update_dropdowns(self):
        # Update Season dropdown
        seasons = {"Winter": 0, "Spring": 0, "Summer": 0, "Fall": 0}
        for item in self.all_items:
            if item[4]:
                s = item[4].capitalize()
                if s in seasons:
                    seasons[s] += 1
        season_dropdown = document.getElementById("seasonDropdown")
        season_dropdown.innerHTML = ""
        opt = document.createElement("option")
        opt.value = "All"
        opt.text = "All"
        season_dropdown.appendChild(opt)
        for s, count in seasons.items():
            if count > 0:
                opt = document.createElement("option")
                opt.value = s
                opt.text = s + " (" + str(count) + ")"
                season_dropdown.appendChild(opt)
        # Update Year dropdown
        year_counts = {}
        for item in self.all_items:
            if item[5]:
                yr = str(item[5])
                year_counts[yr] = year_counts.get(yr, 0) + 1
        year_dropdown = document.getElementById("yearDropdown")
        year_dropdown.innerHTML = ""
        opt = document.createElement("option")
        opt.value = "All"
        opt.text = "All"
        year_dropdown.appendChild(opt)
        for year in sorted(year_counts.keys()):
            opt = document.createElement("option")
            opt.value = year
            opt.text = year + " (" + str(year_counts[year]) + ")"
            year_dropdown.appendChild(opt)

    def filter_changed(self, event=None):
        season = document.getElementById("seasonDropdown").value
        year = document.getElementById("yearDropdown").value
        filtered = []
        for item in self.all_items:
            if season != "All":
                if not item[4] or item[4].lower() != season.lower():
                    continue
            if year != "All":
                if not item[5] or str(item[5]) != year:
                    continue
            filtered.append(item)
        if not filtered:
            self.set_text("progressLabel", "No entries match the selected filters!")
            return
        self.unsorted_list = filtered
        self.sorted_list = [filtered[0]]
        self.current_index = 1
        self.reset_binary_range()
        self.update_progress()
        self.update_comparison_gui()

    # ---------- Edit Sorted List Functions ----------
    def edit_sorted_list(self):
        modal = document.getElementById("editModal")
        modal.style.display = "block"
        self.refresh_edit_modal()

    def refresh_edit_modal(self):
        content = document.getElementById("editModalContent")
        content.innerHTML = ""
        ol = document.createElement("ol")
        for idx, item in enumerate(self.sorted_list):
            li = document.createElement("li")
            li.style.marginBottom = "8px"
            li.innerText = item[1] + " "
            # Up button
            upBtn = document.createElement("button")
            upBtn.innerText = "↑"
            if idx == 0:
                upBtn.disabled = True
            else:
                upBtn.onclick = lambda ev, i=idx: self.move_item_up(i)
            li.appendChild(upBtn)
            # Down button
            downBtn = document.createElement("button")
            downBtn.innerText = "↓"
            if idx == len(self.sorted_list) - 1:
                downBtn.disabled = True
            else:
                downBtn.onclick = lambda ev, i=idx: self.move_item_down(i)
            li.appendChild(downBtn)
            ol.appendChild(li)
        content.appendChild(ol)

    def move_item_up(self, index):
        if index > 0:
            self.sorted_list[index], self.sorted_list[index - 1] = self.sorted_list[index - 1], self.sorted_list[index]
            self.refresh_edit_modal()

    def move_item_down(self, index):
        if index < len(self.sorted_list) - 1:
            self.sorted_list[index], self.sorted_list[index + 1] = self.sorted_list[index + 1], self.sorted_list[index]
            self.refresh_edit_modal()

    def save_edited_list(self):
        modal = document.getElementById("editModal")
        modal.style.display = "none"
        self.set_text("progressLabel", "Edited sorted list saved.")

    def close_edit_modal(self):
        modal = document.getElementById("editModal")
        modal.style.display = "none"

    # ---------- Extra Functions ----------
    def finish_early(self):
        self.show_final_results()

    def reset_tournament(self):
        self.all_items = []
        self.unsorted_list = []
        self.sorted_list = []
        self.current_index = 0
        self.low_index = 0
        self.high_index = 0
        self.initial_estimated_midpoint = None
        self.initial_low_bound = None
        self.comparisons_remaining = 0
        self.unsorted_comparisons_remaining = 0
        self.set_text("progressLabel", "Tournament has been reset. Please fetch a new list.")
        self.set_text("instructionLabel", "Comparison instructions will appear here")
        document.getElementById("unsortedComparisonsLabel").innerText = "Estimated Total Comparisons Left: 0"

    def show_debug_info(self):
        debug_modal = document.getElementById("debugModal")
        content = document.getElementById("debugModalContent")
        info = "---- Debug Information ----\n"
        info += "All Items: " + str(len(self.all_items)) + "\n"
        info += "Unsorted List: " + str(len(self.unsorted_list)) + "\n"
        info += "Sorted List: " + str(len(self.sorted_list)) + "\n"
        info += "Current Index: " + str(self.current_index) + "\n"
        info += "Low Index: " + str(self.low_index) + "\n"
        info += "High Index: " + str(self.high_index) + "\n"
        info += "Comparisons Remaining (unsorted): " + str(self.unsorted_comparisons_remaining)
        content.innerText = info
        debug_modal.style.display = "block"

# Create a global instance
ranker = AniMangaRanker()

# ---------- Bind Event Listeners ----------
def fetch_anime(e):
    import asyncio
    asyncio.create_task(ranker.start_fetch("ANIME"))

def fetch_manga(e):
    import asyncio
    asyncio.create_task(ranker.start_fetch("MANGA"))

document.getElementById("fetchAnimeButton").addEventListener("click", fetch_anime)
document.getElementById("fetchMangaButton").addEventListener("click", fetch_manga)
document.getElementById("compButton1").addEventListener("click", ranker.handle_new_win)
document.getElementById("compButton2").addEventListener("click", ranker.handle_candidate_win)
document.getElementById("editSortedButton").addEventListener("click", lambda e: ranker.edit_sorted_list())
document.getElementById("finishEarlyButton").addEventListener("click", lambda e: ranker.finish_early())
document.getElementById("resetButton").addEventListener("click", lambda e: ranker.reset_tournament())
document.getElementById("debugButton").addEventListener("click", lambda e: ranker.show_debug_info())
document.getElementById("saveEditButton").addEventListener("click", lambda e: ranker.save_edited_list())
document.getElementById("closeEditButton").addEventListener("click", lambda e: ranker.close_edit_modal())
document.getElementById("closeDebugButton").addEventListener("click", lambda e: document.getElementById("debugModal").style.display = "none")
    </py-script>
  </body>
</html>
