<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AniManga Ranker</title>
    <!-- Using a specific version of PyScript (2024.9.2) -->
    <link rel="stylesheet" href="https://pyscript.net/snapshots/2024.9.2/core.css" />
    <script type="module" src="https://pyscript.net/snapshots/2024.9.2/core.js"></script>
    <style>
      /* Restore original dark color scheme */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: #2e2e2e;
        color: #f8f8f2;
      }
      /* Full-width container so the page is wider */
      .container {
        display: flex;
        flex-direction: column;
        height: 100vh; /* full viewport height */
        width: 100%;       /* use full width */
        margin: 0;
        padding: 20px 0;   /* remove horizontal padding so bottom buttons reach the edges */
        box-sizing: border-box;
        font-family: Arial, sans-serif;
      }
      /* Header: dark background with subtle bottom border */
      header {
        flex: 0 0 auto;
        text-align: center;
        padding: 10px 20px;
        background-color: #2e2e2e;
        margin-bottom: 10px;
        border-bottom: 1px solid #444;
      }
      header h1 {
        margin: 0;
        font-size: 1.8em;
        color: #f8f8f2;
      }
      /* Control panel remains at the top */
      .control-panel {
        flex: 0 0 auto;
        margin-bottom: 10px;
        padding: 0 20px;
      }
      .username-status {
        text-align: center;
        margin-bottom: 10px;
      }
      /* Row for main buttons and dropdowns */
      .controls-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        justify-content: center;
        margin-bottom: 10px;
      }
      .btn-group {
        display: flex;
        gap: 10px;
      }
      .btn-group button {
        padding: 8px 12px;
        font-size: 1em;
        cursor: pointer;
      }
      .dropdown-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .dropdown-group label,
      .dropdown-group select {
        font-size: 16px;
      }
      /* Progress info arranged side by side */
      .progress-row {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 10px;
      }
      #progressLabel,
      #unsortedComparisonsLabel {
        font-size: 16px;
      }
      /* Instruction text: centered, on one line without "Compare:" */
      #instructionLabel {
        text-align: center;
        font-size: 1.2em;
        margin-top: 10px;
      }
      /* The comparison panel fills any remaining vertical space */
      .comparison-panel {
        flex: 1;
        display: flex;
        gap: 10px;
        margin-top: 20px;
        align-items: stretch;
      }
      /* Comparison buttons styling:
         - Extend fully within the available width/height.
         - Images inside these buttons will be displayed as block elements so that text appears underneath.
      */
      .comparison-button {
        flex: 1;
        padding: 20px;
        font-size: 18px;
        cursor: pointer;
        background-color: #555;
        color: white;
        border: none;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        overflow: hidden;
      }
      .comparison-button:hover {
        background-color: #666;
      }
      .comparison-button.no-image {
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .comparison-button .title {
        flex: 0 0 auto;
        min-height: 50px;
        text-align: center;
        margin-bottom: 10px;
      }
      .comparison-button .image-container {
        flex: 1 1 auto;
        width: 100%;
        display: flex;
        max-height: calc(100% - 60px);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }
      .comparison-button .image-container img {
        /* Allow width and height to adjust based on containerâ€™s available space */
        width: auto;
        height: 100%;
        object-fit: contain;
        display: block;
        /* Remove margins if centering is handled by the container */
      }
      /* Generic button styling */
      button {
        background-color: #555;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 16px;
        cursor: pointer;
      }
      button:hover {
        background-color: #666;
      }
      /* Modal styling */
      .modal {
        display: none;
        position: fixed;
        z-index: 10;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      }
      .modal-content {
        background-color: #333;
        margin: 10% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 600px;
        color: #f8f8f2;
      }
      .modal-content button {
        margin: 5px;
        font-size: 16px;
      }
      /* New styling for drag items inside the edit modal */
      .drag-item {
        padding: 8px;
        margin: 4px 0;
        border: 1px solid #666;
        border-radius: 4px;
        background-color: #444;
        cursor: move;
        transition: background-color 0.3s;
      }
      .drag-item:hover {
        background-color: #555;
      }
      /* Debug info panel and toggle button */
      #debugInfo {
        display: none;
        position: fixed;
        top: 40px;
        right: 5px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 5px;
        font-size: 12px;
        z-index: 9999;
        white-space: pre-line;
      }
      #debugToggle {
        position: fixed;
        top: 5px;
        right: 5px;
        background: #555;
        color: white;
        padding: 5px;
        z-index: 10000;
        cursor: pointer;
        border-radius: 4px;
      }
      .media-group-container {
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          gap: 5px;
      }
      .media-group-item {
          text-align: center;
          width: 60px; /* adjust as needed */
      }
      .group-image {
          max-width: 100%;
          height: auto;
          border-radius: 3px;
      }
      .group-title {
          font-size: 10px;
          margin-top: 3px;
          color: #f8f8f2;
      }
      .progress-row {
      display: flex;           /* Arrange children in a horizontal row */
      align-items: center;     /* Optional: vertically center align content */
      gap: 5px;                  /* No gap between the two elements */
      }  
    </style>
  </head>
  <body>
    <!-- Debug toggle button -->
    <div id="debugToggle">DEBUG</div>
    <!-- Debug info panel -->
    <div id="debugInfo"></div>
    
    <div class="container">
      <!-- Header -->
      <header>
        <h1>AniManga Ranker</h1>
      </header>
      
      <div class="control-panel">
        <!-- Username and checkboxes -->
        <div class="username-status">
          <div>
            <label for="usernameInput">Enter AniList Username:</label>
            <input type="text" id="usernameInput" placeholder="Username" title="Enter your AniList username" />
            <!-- New text to the right of the username input -->
            <span class="auto-save-text" style="margin-left: 10px; color: #aaa; font-style: italic;">
              Progress saves automatically!
            </span>
          </div>
          <div>
            <label><input type="checkbox" id="completedCheckbox" checked> Completed</label>
            <label><input type="checkbox" id="watchingCheckbox"> Watching/Reading</label>
            <label><input type="checkbox" id="pausedCheckbox"> Paused</label>
            <label><input type="checkbox" id="droppedCheckbox"> Dropped</label>
            <label><input type="checkbox" id="includeImagesCheckbox"> Include Images</label>
          </div>
          <div>
            <label>
              <input type="checkbox" id="groupSeriesCheckbox" title="Group related series (sequels and prequels) together">
              Group Related Series
            </label>
          </div>
          <!-- New format filter checkboxes -->
          <div class="format-filters" style="margin-top: 10px;">
            <fieldset id="animeFormatFilters" style="display: inline-block; margin-right: 20px;">
              <legend>Anime Formats</legend>
              <label><input type="checkbox" id="formatTV" checked> TV</label>
              <label><input type="checkbox" id="formatMovie" checked> Movie</label>
              <label><input type="checkbox" id="formatTVShort" checked> TV Short</label>
              <label><input type="checkbox" id="formatSpecial" checked> Special</label>
              <label><input type="checkbox" id="formatOVA" checked> OVA</label>
              <label><input type="checkbox" id="formatONA" checked> ONA</label>
              <label><input type="checkbox" id="formatMusic" checked> Music</label>
            </fieldset>
          
            <fieldset id="mangaFormatFilters" style="display: inline-block;">
              <legend>Manga Formats</legend>
              <label><input type="checkbox" id="formatManga" checked> Manga</label>
              <label><input type="checkbox" id="formatNovel" checked> Novel</label>
              <label><input type="checkbox" id="formatOneShot" checked> One Shot</label>
            </fieldset>
          </div>
        </div>
        
        <!-- Row containing the main buttons and dropdowns -->
        <div class="controls-row">
          <div class="btn-group">
            <button id="fetchAnimeButton">Fetch Anime List</button>
            <button id="fetchMangaButton">Fetch Manga List</button>
            <button id="editSortedButton">Edit Sorted List</button>
            <button id="finishEarlyButton">Finish List Early</button>
          </div>
          <div class="dropdown-group">
            <label for="seasonDropdown">Season:</label>
            <select id="seasonDropdown"></select>
            <label for="yearDropdown">Year:</label>
            <select id="yearDropdown"></select>
          </div>
        </div>
        
        <!-- Progress and status -->
        <div class="progress-row">
          <div id="progressLabel">Inserted 0 of 0. Remaining: 0 items (0% complete).</div>
          <div id="unsortedComparisonsLabel">Estimated Total Comparisons Left: 0</div>
        </div>
        
        <!-- Instruction text (a centered single line) -->
        <div id="instructionLabel">Comparison instructions will appear here</div>
      </div>
      
      <!-- Comparison buttons panel filling remaining vertical space -->
      <div class="comparison-panel">
        <button class="comparison-button" id="compButton1">NEW wins</button>
        <button class="comparison-button" id="compButton2">Candidate wins</button>
      </div>
    </div>
    
    <!-- Edit Sorted List Modal (drag-and-drop enabled) -->
    <div id="editModal" class="modal">
      <div class="modal-content">
        <h2>Edit Sorted List</h2>
        <!-- Instruction for dragging -->
        <p style="text-align:center; font-style: italic;">Drag and drop to adjust your list</p>
        <div id="editModalContent"></div>
        <div style="text-align: center;">
          <button id="saveEditButton">Save</button>
          <button id="closeEditButton">Close</button>
        </div>
      </div>
    </div>
    
    <script>
      // Function to open the modal
      function openEditModal() {
        const modal = document.getElementById("editModal");
        modal.style.display = "block";
    
        // Add keydown event listener for closing with Escape key
        document.addEventListener("keydown", function handleEscape(event) {
          if (event.key === "Escape") {
            closeEditModal();
            // Remove the event listener to prevent memory leaks
            document.removeEventListener("keydown", handleEscape);
          }
        });
      }
    
      // Function to close the modal
      function closeEditModal() {
        const modal = document.getElementById("editModal");
        modal.style.display = "none";
      }
    
      // Add event listener for the Close button
      document.getElementById("closeEditButton").addEventListener("click", closeEditModal);
    
      // Example usage: Attach openEditModal to a button (optional)
      document.getElementById("editSortedButton").addEventListener("click", openEditModal);
    </script>
    
    <!-- Final Ranking Modal -->
    <div id="finalModal" class="modal">
      <div class="modal-content">
        <h2>Final Ranking</h2>
        <div id="finalModalContent"></div>
        <div style="text-align: center;">
          <button id="closeFinalButton">Close</button>
        </div>
      </div>
    </div>
    
    <!-- Python code (PyScript) -->
    <script type="py">
import math, random, json
from js import document, console
from pyodide.http import pyfetch
from pyodide.ffi import create_proxy

# Use the absolute URL with a trailing slash so it is not misinterpreted as relative
ANILIST_API_URL = "https://graphql.anilist.co/"

class AniMangaRanker:
    def __init__(self):
        # Tournament state variables
        self.all_items = []       # All fetched items
        self.unsorted_list = []   # Items to be inserted in ranking
        self.sorted_list = []     # Ranked items
        self.current_index = 0
        self.low_index = 0
        self.high_index = 0
        self.offset = 15
        self.initial_estimated_midpoint = None
        self.initial_low_bound = None
        self.comparisons_remaining = 0
        self.unsorted_comparisons_remaining = 0

    # ---------- DOM Utility Methods ----------
    def set_text(self, element_id, text):
        document.getElementById(element_id).innerText = text

    def get_value(self, element_id):
        return document.getElementById(element_id).value

    def is_checked(self, element_id):
        return document.getElementById(element_id).checked

    # ---------- AniList API Functions ----------
    def build_query(self, media_type, status):
        return (
            "query ($name: String) { "
            "MediaListCollection(userName: $name, type: " + media_type + ", status: " + status + ") { "
            "lists { entries { score media { "
                "id title { english romaji } coverImage { extraLarge } season seasonYear format "
                "relations { edges { relationType node { id title { english romaji } } } } "
            "} } } } }"
        )


    def get_selected_statuses(self, media_type):
        statuses = []
        if self.is_checked("completedCheckbox"):
            statuses.append("COMPLETED")
        if self.is_checked("watchingCheckbox"):
            statuses.append("CURRENT", "REPEATING")
        if self.is_checked("pausedCheckbox"):
            statuses.append("PAUSED")
        if self.is_checked("droppedCheckbox"):
            statuses.append("DROPPED")
        return statuses

    async def fetch_user_list(self, username, media_type):
        statuses = self.get_selected_statuses(media_type)
        if not statuses:
            self.set_text("progressLabel", "No list statuses selected!")
            return []
        # Initialize new_results before processing statuses.
        new_results = []
        seen = set()
        for status in statuses:
            query = self.build_query(media_type, status)
            variables = {"name": username}
            payload = {"query": query, "variables": variables}
            try:
                response = await pyfetch(
                    url=ANILIST_API_URL,  # Notice the trailing slash
                    method="POST",
                    headers={"Content-Type": "application/json"},
                    body=json.dumps(payload)
                )
                if not response.ok:
                    console.log("Error fetching data: " + str(response.status))
                    continue
                data = await response.json()
            except Exception as e:
                console.log("Error fetching " + media_type + " list for " + username + ": " + str(e))
                continue
            raw_lists = data.get("data", {}).get("MediaListCollection", {}).get("lists", [])
            local_results = []
            for lst in raw_lists:
                for entry in lst.get("entries", []):
                    media = entry.get("media")
                    if media:
                        mid = media.get("id")
                        if mid in seen:
                            continue
                        seen.add(mid)

                        # --- NEW: Check the media format ---
                        # Get the media's format from the API
                        entry_format = media.get("format")
                        # Only include this entry if its format is one of the ones the user selected
                        if not entry_format or entry_format not in self.get_selected_formats(media_type):
                            continue
                        # -------------------------------------
      
                        title = (media.get("title", {}).get("english") or 
                                 media.get("title", {}).get("romaji") or "Unknown")
                        cover = media.get("coverImage", {}).get("extraLarge", "")
                        season = media.get("season")
                        seasonYear = media.get("seasonYear")
                        score = entry.get("score", 0)
                        relations = media.get("relations", {}).get("edges", [])
                        local_results.append((mid, title, cover, score, season, seasonYear))
            local_results.sort(key=lambda x: x[3], reverse=True)
            current_score = None
            group = []
            for item in local_results:
                score = item[3]
                if current_score is None or score == current_score:
                    group.append(item)
                    current_score = score
                else:
                    random.shuffle(group)
                    new_results.extend(group)
                    group = [item]
                    current_score = score
            if group:
                random.shuffle(group)
                new_results.extend(group)
        return new_results
    
    def group_related_items(sorted_list):
        """
        Groups media items into lists based on direct PREQUEL/SEQUEL relationships.
        Each media item is a tuple: (id, title, cover, score, season, seasonYear, relations)
        """
        parent = {}
    
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
    
        def union(x, y):
            root_x = find(x)
            root_y = find(y)
            if root_x != root_y:
                parent[root_y] = root_x
    
        # Each item starts as its own parent.
        for item in sorted_list:
            media_id = item[0]
            parent[media_id] = media_id
    
        # Union items that share a PREQUEL or SEQUEL relation.
        for item in sorted_list:
            media_id = item[0]
            relations = item[6] if len(item) > 6 else []
            for relation in relations:
                if relation.get("relationType") in ("PREQUEL", "SEQUEL"):
                    related_id = relation.get("node", {}).get("id")
                    if related_id in parent:
                        union(media_id, related_id)
    
        # Build groups using the union-find structure.
        groups = {}
        for item in sorted_list:
            root = find(item[0])
            groups.setdefault(root, []).append(item)
        return list(groups.values())
  
    # ---------- Tournament and Comparison Functions ----------
    def estimated_unsorted_comparisons_remaining(self):
        sorted_count = len(self.sorted_list)
        remaining_count = len(self.unsorted_list) - self.current_index
        total = 0
        for k in range(remaining_count):
            total += math.ceil(math.log2(sorted_count + k + 1))
        return total

    def reset_binary_range(self) -> None:
        self.high_index = len(self.sorted_list) - 1
        if self.high_index >= 2 * self.offset:
            self.low_index = self.high_index - 2 * self.offset
        else:
            self.low_index = 0
        self.initial_low_bound = self.low_index
        candidate = self.low_index + self.offset
        if candidate <= self.high_index:
            self.initial_estimated_midpoint = candidate
        else:
            self.initial_estimated_midpoint = (self.low_index + self.high_index) // 2
        # Resetting of the current binary search estimates.
        self.comparisons_remaining = math.ceil(math.log2(self.high_index - self.low_index + 1)) if (self.high_index - self.low_index + 1) > 0 else 0
        # Update the unsorted comparisons estimate.
        self.unsorted_comparisons_remaining = self.estimated_unsorted_comparisons_remaining()
        self.update_debug_info()
    
    def calculate_mid(self) -> int:
        # Uses the offset until the search is expanded; after expansion, uses the arithmetic midpoint.
        if self.initial_low_bound is not None and self.initial_low_bound > 0 and self.low_index == 0:
            return (self.low_index + self.high_index) // 2
        else:
            candidate = self.low_index + self.offset
            if candidate <= self.high_index:
                return candidate
            else:
                return (self.low_index + self.high_index) // 2

    def update_progress(self):
        total = len(self.unsorted_list)
        inserted = len(self.sorted_list)
        remaining_items = total - inserted
        progress_percentage = (inserted / total * 100) if total > 0 else 0
        self.set_text("progressLabel",
                      "Inserted " + str(inserted) + " of " + str(total) + ". Remaining: " + 
                      str(remaining_items) + " items ({:.1f}% complete).".format(progress_percentage))

    def update_comparison_gui(self, mid: int = None) -> None:
        try:
            if self.current_index >= len(self.unsorted_list):
                return
            new_item = self.unsorted_list[self.current_index]
            if not self.sorted_list:
                self.sorted_list.append(new_item)
                self.current_index += 1
                self.reset_binary_range()
                if self.current_index < len(self.unsorted_list):
                    self.update_comparison_gui()
                else:
                    self.show_final_results()
                return
    
            mid = self.calculate_mid()
            if mid < 0 or mid >= len(self.sorted_list):
                mid = 0
            candidate = self.sorted_list[mid]
    
            self.set_text("instructionLabel", new_item[1] + " vs " + candidate[1])
            btn1 = document.getElementById("compButton1")
            btn2 = document.getElementById("compButton2")
            include_images = self.is_checked("includeImagesCheckbox")
    
            # If grouping is enabled, treat items as groups
            if self.is_checked("groupSeriesCheckbox"):
                new_item_group = new_item if isinstance(new_item, list) else [new_item]
                candidate_group = candidate if isinstance(candidate, list) else [candidate]
                btn1.innerHTML = build_group_html(new_item_group, include_images)
                btn2.innerHTML = build_group_html(candidate_group, include_images)
            else:
                # Otherwise, display single items
                if include_images and new_item[2] and candidate[2]:
                    btn1.innerHTML = (
                        f'<div class="title">{new_item[1]}</div>'
                        f'<div class="image-container">'
                        f'<img src="{new_item[2]}" alt="Cover for {new_item[1]}">'
                        f'</div>'
                    )
                    btn2.innerHTML = (
                        f'<div class="title">{candidate[1]}</div>'
                        f'<div class="image-container">'
                        f'<img src="{candidate[2]}" alt="Cover for {candidate[1]}">'
                        f'</div>'
                    )
                else:
                    btn1.classList.add("no-image")
                    btn2.classList.add("no-image")
                    btn1.innerText = new_item[1]
                    btn2.innerText = candidate[1]
            self.update_progress()
            self.update_debug_info()
        except Exception as e:
            console.log("Error in update_comparison_gui: " + str(e))

    def get_selected_formats(self, media_type):
        selected_formats = set()
        if media_type == "ANIME":
            if document.getElementById("formatTV").checked:
                selected_formats.add("TV")
            if document.getElementById("formatMovie").checked:
                selected_formats.add("MOVIE")
            if document.getElementById("formatTVShort").checked:
                selected_formats.add("TV_SHORT")
            if document.getElementById("formatSpecial").checked:
                selected_formats.add("SPECIAL")
            if document.getElementById("formatOVA").checked:
                selected_formats.add("OVA")
            if document.getElementById("formatONA").checked:
                selected_formats.add("ONA")
            if document.getElementById("formatMusic").checked:
                selected_formats.add("MUSIC")
        elif media_type == "MANGA":
            if document.getElementById("formatManga").checked:
                selected_formats.add("MANGA")
            if document.getElementById("formatNovel").checked:
                selected_formats.add("NOVEL")
            if document.getElementById("formatOneShot").checked:
                selected_formats.add("ONE_SHOT")
        return selected_formats

    def handle_comparison(self, new_item_wins):
        try:
            if self.unsorted_comparisons_remaining > 0:
                self.unsorted_comparisons_remaining -= 1
                self.set_text("unsortedComparisonsLabel",
                              "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))
            mid = self.calculate_mid()
            if self.low_index >= self.high_index:
                if new_item_wins and (self.initial_low_bound is not None and self.initial_low_bound != 0 and self.low_index == self.initial_low_bound):
                    self.high_index = self.initial_low_bound
                    self.low_index = 0
                    self.update_comparison_gui(self.calculate_mid())
                    self.save_progress()  # Save here before return.
                    return
                else:
                    insertion_index = self.low_index if new_item_wins else self.low_index + 1
                    self.sorted_list.insert(insertion_index, self.unsorted_list[self.current_index])
                    self.current_index += 1
                    self.reset_binary_range()
                    if self.current_index < len(self.unsorted_list):
                        self.update_comparison_gui(self.calculate_mid())
                    else:
                        self.show_final_results()
                    self.save_progress()  # Save here before return.
                    return
            if new_item_wins:
                self.high_index = mid - 1
            else:
                self.low_index = mid + 1
            if self.low_index > self.high_index:
                insertion_index = self.low_index if new_item_wins else self.low_index + 1
                self.sorted_list.insert(insertion_index, self.unsorted_list[self.current_index])
                self.current_index += 1
                self.reset_binary_range()
                if self.current_index < len(self.unsorted_list):
                    self.update_comparison_gui()
                else:
                    self.show_final_results()
                self.save_progress()  # Save after updating state.
                return
            else:
                self.update_comparison_gui(self.calculate_mid())
            self.save_progress()  # Fallback save at the end if no early return.
        except Exception as e:
            console.log("Error in handle_comparison: " + str(e))

    def handle_new_win(self, e):
        self.handle_comparison(True)

    def handle_candidate_win(self, e):
        self.handle_comparison(False)

    def show_final_results(self):
        try:
            if self.is_checked("groupSeriesCheckbox"):
                groups = group_related_items(self.sorted_list)
            else:
                groups = [[item] for item in self.sorted_list]  # Each item becomes its own group.
    
            final_text = "Final Ranking (Best to Worst):\n\n"
            for idx, group in enumerate(groups):
                final_text += f"Group {idx+1}:\n"
                for item in group:
                    final_text += f"  - {item[1]}\n"
                final_text += "\n"
            finalModal = document.getElementById("finalModal")
            document.getElementById("finalModalContent").innerText = final_text
            finalModal.style.display = "block"
            self.set_text("progressLabel", "Ranking complete!")
        except Exception as e:
            console.log("Error in show_final_results: " + str(e))


    async def start_fetch(self, media_type):
        try:
            username = self.get_value("usernameInput").strip()
            if not username:
                self.set_text("progressLabel", "Please enter a username!")
                return
            self.set_text("progressLabel", "Fetching data, please wait...")
            items = await self.fetch_user_list(username, media_type)
            if not items:
                self.set_text("progressLabel", "No completed " + media_type.lower() + " found for " + username)
                return
            self.all_items = items
            self.update_dropdowns()  # Update dropdowns based on fetched data
            self.unsorted_list = items
            self.sorted_list = [items[0]]
            self.current_index = 1
            self.reset_binary_range()
            self.update_progress()
            # Update the unsorted comparisons label immediately:
            self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))
            self.update_comparison_gui()
            self.save_progress()  # Save state here!
        except Exception as e:
            console.log("Error in start_fetch: " + str(e))

    def update_dropdowns(self):
        try:
            # Preserve current selection (default to "All")
            current_year = document.getElementById("yearDropdown").value or "All"
            current_season = document.getElementById("seasonDropdown").value or "All"
            # Update Season dropdown counts based on current year filter
            seasons = {"Winter": 0, "Spring": 0, "Summer": 0, "Fall": 0}
            for item in self.all_items:
                if current_year != "All":
                    if not item[5] or str(item[5]) != current_year:
                        continue
                if item[4]:
                    s = item[4].capitalize()
                    if s in seasons:
                        seasons[s] += 1
            total_seasons = sum(seasons.values())
            season_dropdown = document.getElementById("seasonDropdown")
            season_dropdown.innerHTML = ""
            opt = document.createElement("option")
            opt.value = "All"
            opt.text = "All (" + str(total_seasons) + ")"
            season_dropdown.appendChild(opt)
            for s, count in seasons.items():
                if count > 0:
                    opt = document.createElement("option")
                    opt.value = s
                    opt.text = f"{s} ({count})"
                    season_dropdown.appendChild(opt)
            season_dropdown.value = current_season;
            
            # Update Year dropdown counts based on current season filter
            year_counts = {}
            for item in self.all_items:
                if current_season != "All":
                    if not item[4] or item[4].capitalize() != current_season:
                        continue
                if item[5]:
                    yr = str(item[5])
                    year_counts[yr] = year_counts.get(yr, 0) + 1
            total_years = sum(year_counts.values())
            year_dropdown = document.getElementById("yearDropdown")
            year_dropdown.innerHTML = ""
            opt = document.createElement("option")
            opt.value = "All"
            opt.text = "All (" + str(total_years) + ")"
            year_dropdown.appendChild(opt)
            for year in sorted(year_counts.keys()):
                opt = document.createElement("option")
                opt.value = year
                opt.text = f"{year} ({year_counts[year]})"
                year_dropdown.appendChild(opt)
            year_dropdown.value = current_year;
            
        except Exception as e:
            console.log("Error in update_dropdowns: " + str(e))

    def filter_changed(self, e=None):
        try:
            self.update_dropdowns()
            season = document.getElementById("seasonDropdown").value
            year = document.getElementById("yearDropdown").value
            filtered = []
            for item in self.all_items:
                if season != "All" and (not item[4] or item[4].lower() != season.lower()):
                    continue
                if year != "All" and (not item[5] or str(item[5]) != year):
                    continue
                filtered.append(item)
            if not filtered:
                self.set_text("progressLabel", "No entries match the selected filters!")
                return
            self.unsorted_list = filtered
            self.sorted_list = [filtered[0]]
            self.current_index = 1
            self.reset_binary_range()
            self.update_progress()
            # Update the unsorted comparisons label after filters change:
            self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))
            self.update_comparison_gui()
            self.save_progress()  # Save state after filter changes.
        except Exception as e:
            console.log("Error in filter_changed: " + str(e))

    def edit_sorted_list(self):
        try:
            modal = document.getElementById("editModal")
            modal.style.display = "block"
            if self.is_checked("groupSeriesCheckbox"):
                self.refresh_edit_modal_grouped()
            else:
                self.refresh_edit_modal()
        except Exception as e:
            console.log("Error in edit_sorted_list: " + str(e))

    def refresh_edit_modal_grouped(self):
        try:
            content = document.getElementById("editModalContent")
            content.innerHTML = ""
            groups = group_related_items(self.sorted_list)
            ol = document.createElement("ol")
            for idx, group in enumerate(groups):
                li = document.createElement("li")
                li.className = "drag-item"
                li.setAttribute("draggable", "true")
                group_html = f"<div><strong>Group {idx+1}:</strong></div>"
                for item in group:
                    group_html += f"<div>{item[1]}</div>"
                li.innerHTML = group_html
                li.addEventListener("dragstart", create_proxy(lambda e, i=idx: self.on_drag_start(e, i)))
                li.addEventListener("dragover", create_proxy(self.on_drag_over))
                li.addEventListener("drop", create_proxy(lambda e, i=idx: self.on_drop_group(e, i)))
                ol.appendChild(li)
            content.appendChild(ol)
        except Exception as e:
            console.log("Error in refresh_edit_modal_grouped: " + str(e))

    def on_drop_group(self, e, group_index):
        e.preventDefault()
        src_index = int(e.dataTransfer.getData("text/plain"))
        if src_index != group_index:
            groups = group_related_items(self.sorted_list)
            moved_group = groups.pop(src_index)
            groups.insert(group_index, moved_group)
            # Flatten the list back.
            new_sorted = []
            for group in groups:
                new_sorted.extend(group)
            self.sorted_list = new_sorted
            self.refresh_edit_modal_grouped()

    def on_drag_start(self, e, index):
        e.dataTransfer.setData("text/plain", str(index))

    def on_drag_over(self, e):
        e.preventDefault()

    def on_drop(self, e, index):
        e.preventDefault()
        src_index = int(e.dataTransfer.getData("text/plain"))
        if src_index != index:
            item = self.sorted_list.pop(src_index)
            self.sorted_list.insert(index, item)
            self.refresh_edit_modal()

    def refresh_edit_modal(self):
        try:
            content = document.getElementById("editModalContent")
            content.innerHTML = ""
            ol = document.createElement("ol")
            for idx, item in enumerate(self.sorted_list):
                li = document.createElement("li")
                li.innerText = item[1]
                li.className = "drag-item"  # apply the drag-item styling
                li.setAttribute("draggable", "true")
                li.addEventListener("dragstart", create_proxy(lambda e, i=idx: self.on_drag_start(e, i)))
                li.addEventListener("dragover", create_proxy(self.on_drag_over))
                li.addEventListener("drop", create_proxy(lambda e, i=idx: self.on_drop(e, i)))
                ol.appendChild(li)
            content.appendChild(ol)
        except Exception as e:
            console.log("Error in refresh_edit_modal: " + str(e))

    def save_edited_list(self):
        try:
            modal = document.getElementById("editModal")
            modal.style.display = "none"
            self.set_text("progressLabel", "Edited sorted list saved.")
            self.save_progress()  # Save the new sorted order.
        except Exception as e:
            console.log("Error in save_edited_list: " + str(e))

    def close_edit_modal(self):
        try:
            modal = document.getElementById("editModal")
            modal.style.display = "none"
        except Exception as e:
            console.log("Error in close_edit_modal: " + str(e))

    def finish_early(self):
        try:
            self.show_final_results()
            self.save_progress()  # Save the finished state.
        except Exception as e:
            console.log("Error in finish_early: " + str(e))

    def show_final_results(self):
        try:
            final_text = "Final Ranking (Best to Worst):\n\n"
            for i, comp in enumerate(self.sorted_list):
                final_text += str(i+1) + ". " + comp[1] + "\n"
            finalModal = document.getElementById("finalModal")
            document.getElementById("finalModalContent").innerText = final_text
            finalModal.style.display = "block"
            self.set_text("progressLabel", "Ranking complete!")
        except Exception as e:
            console.log("Error in show_final_results: " + str(e))

    def update_debug_info(self):
        try:
            debugInfo = document.getElementById("debugInfo")
            low_item = self.sorted_list[self.low_index][1] if self.sorted_list and self.low_index < len(self.sorted_list) else "N/A"
            high_item = self.sorted_list[self.high_index][1] if self.sorted_list and self.high_index < len(self.sorted_list) else "N/A"
            initial_item = self.sorted_list[self.initial_estimated_midpoint][1] if self.initial_estimated_midpoint is not None and self.sorted_list and self.initial_estimated_midpoint < len(self.sorted_list) else "N/A"
            current_mid = self.calculate_mid()
            current_item = self.sorted_list[current_mid][1] if self.sorted_list and current_mid < len(self.sorted_list) else "N/A"
            info = (f"Low bound: {low_item} (index {self.low_index})\n"
                    f"High bound: {high_item} (index {self.high_index})\n"
                    f"Initial midpoint: {initial_item} (index {self.initial_estimated_midpoint})\n"
                    f"Current midpoint: {current_item} (index {current_mid})")
            debugInfo.innerText = info
        except Exception as e:
            console.log("Error updating debug info: " + str(e))
    
    def save_progress(self):
        """
        Saves the complete state of the application to localStorage.
        This includes ranking variables and UI element values so that the
        session can be fully restored later.
        """
        state = {
            "all_items": self.all_items,
            "unsorted_list": self.unsorted_list,
            "sorted_list": self.sorted_list,
            "current_index": self.current_index,
            "low_index": self.low_index,
            "high_index": self.high_index,
            "offset": self.offset,
            "initial_estimated_midpoint": self.initial_estimated_midpoint,
            "initial_low_bound": self.initial_low_bound,
            "unsorted_comparisons_remaining": self.unsorted_comparisons_remaining,
            "seasonDropdown": document.getElementById("seasonDropdown").value,
            "yearDropdown": document.getElementById("yearDropdown").value,
            # Save UI states:
            "username": document.getElementById("usernameInput").value,
            "completedCheckbox": document.getElementById("completedCheckbox").checked,
            "watchingCheckbox": document.getElementById("watchingCheckbox").checked,
            "pausedCheckbox": document.getElementById("pausedCheckbox").checked,
            "droppedCheckbox": document.getElementById("droppedCheckbox").checked,
            "includeImagesCheckbox": document.getElementById("includeImagesCheckbox").checked,
            "formatTV": document.getElementById("formatTV").checked,
            "formatMovie": document.getElementById("formatMovie").checked,
            "formatTVShort": document.getElementById("formatTVShort").checked,
            "formatSpecial": document.getElementById("formatSpecial").checked,
            "formatOVA": document.getElementById("formatOVA").checked,
            "formatONA": document.getElementById("formatONA").checked,
            "formatMusic": document.getElementById("formatMusic").checked,
            "formatManga": document.getElementById("formatManga").checked,
            "formatNovel": document.getElementById("formatNovel").checked,
            "formatOneShot": document.getElementById("formatOneShot").checked,
            "groupSeriesEnabled": document.getElementById("groupSeriesCheckbox").checked,
        }
        from js import localStorage, console
        localStorage.setItem("aniRankerState", json.dumps(state))
        console.log("Progress saved.")

    def load_progress(self):
        from js import document, console, localStorage
        state_json = localStorage.getItem("aniRankerState")
        if state_json:
            try:
                state = json.loads(state_json)
                
                # Restore your core saved properties:
                self.all_items = state.get("all_items", [])
                self.unsorted_list = state.get("unsorted_list", [])
                self.sorted_list = state.get("sorted_list", [])
                self.current_index = state.get("current_index", 0)
                self.low_index = state.get("low_index", 0)
                self.high_index = state.get("high_index", 0)
                self.offset = state.get("offset", 15)
                self.initial_estimated_midpoint = state.get("initial_estimated_midpoint", None)
                self.initial_low_bound = state.get("initial_low_bound", None)
                self.unsorted_comparisons_remaining = state.get("unsorted_comparisons_remaining", 0)
                
                # Restore UI elements that don't involve rebuilds.
                document.getElementById("usernameInput").value = state.get("username", "")
                document.getElementById("completedCheckbox").checked = state.get("completedCheckbox", True)
                document.getElementById("watchingCheckbox").checked = state.get("watchingCheckbox", False)
                document.getElementById("pausedCheckbox").checked = state.get("pausedCheckbox", False)
                document.getElementById("droppedCheckbox").checked = state.get("droppedCheckbox", False)
                document.getElementById("includeImagesCheckbox").checked = state.get("includeImagesCheckbox", False)
                document.getElementById("groupSeriesCheckbox").checked = state.get("groupSeriesCheckbox", False)

                # Restore new format checkbox states:
                document.getElementById("formatTV").checked = state.get("formatTV", True)
                document.getElementById("formatMovie").checked = state.get("formatMovie", True)
                document.getElementById("formatTVShort").checked = state.get("formatTVShort", True)
                document.getElementById("formatSpecial").checked = state.get("formatSpecial", True)
                document.getElementById("formatOVA").checked = state.get("formatOVA", True)
                document.getElementById("formatONA").checked = state.get("formatONA", True)
                document.getElementById("formatMusic").checked = state.get("formatMusic", True)
                document.getElementById("formatManga").checked = state.get("formatManga", True)
                document.getElementById("formatNovel").checked = state.get("formatNovel", True)
                document.getElementById("formatOneShot").checked = state.get("formatOneShot", True)
            
                # Now restore the filter values so they are not overwritten.
                saved_season = state.get("seasonDropdown", "All")
                saved_year = state.get("yearDropdown", "All")
                # Adjust capitalization if needed (e.g., "winter" -> "Winter")
                saved_season = saved_season if saved_season == "All" else saved_season.capitalize()
                document.getElementById("seasonDropdown").value = saved_season
                document.getElementById("yearDropdown").value = state.get("yearDropdown", "All")

                # First, repopulate the dropdown options based on self.all_items.
                self.update_dropdowns()
                
                self.reset_binary_range()  # Recalculate comparisons remaining based on the current sorted list.
                self.set_text("unsortedComparisonsLabel", "Estimated Total Comparisons Left: " + str(self.unsorted_comparisons_remaining))

                self.update_progress()
                self.update_comparison_gui()
                console.log("Progress loaded.")
            except Exception as e:
                console.log("Error loading progress: " + str(e))
    
    def build_group_html(media_group, include_images):
        # media_group is a list of media item tuples.
        html = "<div class='media-group-container'>"
        for item in media_group:
            html += "<div class='media-group-item'>"
            if include_images and item[2]:
                html += f"<img src='{item[2]}' alt='Cover for {item[1]}' class='group-image'>"
            html += f"<div class='group-title'>{item[1]}</div>"
            html += "</div>"
        html += "</div>"
        return html

# Create the global instance of ranker
ranker = AniMangaRanker()

from js import document, localStorage, console
from pyodide.ffi import create_proxy

def show_restore_modal():
    if localStorage.getItem("aniRankerState"):
        document.getElementById("restoreModal").style.display = "block"

def continue_session(e):
    document.getElementById("restoreModal").style.display = "none"
    ranker.load_progress()  # Load the saved progress.
    console.log("Resuming saved session.")

def start_new_session(e):
    document.getElementById("restoreModal").style.display = "none"
    localStorage.removeItem("aniRankerState")
    console.log("Starting a new session.")

# Attach event listeners to modal buttons.
document.getElementById("continueSession").addEventListener("click", create_proxy(continue_session))
document.getElementById("startNewSession").addEventListener("click", create_proxy(start_new_session))

# On page load, show the restore modal if saved progress exists.
show_restore_modal()

# ---------- Bind Event Listeners using create_proxy ----------
fetchAnimeProxy = create_proxy(lambda e: __import__('asyncio').create_task(ranker.start_fetch("ANIME")))
fetchMangaProxy = create_proxy(lambda e: __import__('asyncio').create_task(ranker.start_fetch("MANGA")))
compButton1Proxy = create_proxy(ranker.handle_new_win)
compButton2Proxy = create_proxy(ranker.handle_candidate_win)
editSortedProxy = create_proxy(lambda e: ranker.edit_sorted_list())
finishEarlyProxy = create_proxy(lambda e: ranker.finish_early())
saveEditProxy = create_proxy(lambda e: ranker.save_edited_list())
closeEditProxy = create_proxy(lambda e: ranker.close_edit_modal())
seasonChangeProxy = create_proxy(lambda e: ranker.filter_changed())
yearChangeProxy = create_proxy(lambda e: ranker.filter_changed())
closeFinalProxy = create_proxy(lambda e: setattr(document.getElementById("finalModal").style, "display", "none"))

document.getElementById("fetchAnimeButton").addEventListener("click", fetchAnimeProxy)
document.getElementById("fetchMangaButton").addEventListener("click", fetchMangaProxy)
document.getElementById("compButton1").addEventListener("click", compButton1Proxy)
document.getElementById("compButton2").addEventListener("click", compButton2Proxy)
document.getElementById("editSortedButton").addEventListener("click", editSortedProxy)
document.getElementById("finishEarlyButton").addEventListener("click", finishEarlyProxy)
document.getElementById("saveEditButton").addEventListener("click", saveEditProxy)
document.getElementById("closeEditButton").addEventListener("click", closeEditProxy)
document.getElementById("closeFinalButton").addEventListener("click", closeFinalProxy)

seasonChangeProxy = create_proxy(lambda e: ranker.filter_changed())
yearChangeProxy = create_proxy(lambda e: ranker.filter_changed())
document.getElementById("seasonDropdown").addEventListener("change", seasonChangeProxy)
document.getElementById("yearDropdown").addEventListener("change", yearChangeProxy)
    </script>
    
    <!-- Toggle debug info visibility -->
    <script>
      document.getElementById("debugToggle").addEventListener("click", function(){
        var dbg = document.getElementById("debugInfo");
        if (dbg.style.display === "none" || dbg.style.display === "") {
          dbg.style.display = "block";
        } else {
          dbg.style.display = "none";
        }
      });
    </script>
    <script>
      function adjustComparisonPanelHeight() {
        // Select key elements
        const header = document.querySelector('header');
        const controlPanel = document.querySelector('.control-panel');
        const comparisonPanel = document.querySelector('.comparison-panel');
    
        // Get the heights:
        const headerHeight = header ? header.offsetHeight : 0;
        const controlPanelHeight = controlPanel ? controlPanel.offsetHeight : 0;
        
        // .container has 20px top and 20px bottom padding from "padding: 20px 0;"
        const containerPadding = 40; // Total vertical padding from .container
    
        // Add extra space contributed by margins 
        // (e.g. header has margin-bottom: 10px and control panel may have a margin-bottom)
        const extraMargins = 20; // You can adjust this value to fine-tune.
    
        // Compute space already used by non-button content.
        const usedHeight = headerHeight + controlPanelHeight + containerPadding + extraMargins;
    
        // Calculate available height for the comparison panel.
        const availableHeight = window.innerHeight - usedHeight;
    
        // Set the height of the comparison panel to exactly this value.
        comparisonPanel.style.height = availableHeight + "px";
      }
    
      // Run the function on load and whenever the window is resized
      window.addEventListener("load", adjustComparisonPanelHeight);
      window.addEventListener("resize", adjustComparisonPanelHeight);
    </script>
    <!-- Restore Session Modal -->
    <div id="restoreModal" class="modal" style="display: none;">
      <div class="modal-content" style="padding: 20px; background: #333; color: #fff; border-radius: 5px;">
        <h2 style="margin-top: 0;">Restore Session?</h2>
        <p>Saved progress was detected. Would you like to continue where you left off or start a new session?</p>
        <button id="continueSession">Continue Previous Session</button>
        <button id="startNewSession">Start New Session</button>
      </div>
    </div>
  </body>
</html>
